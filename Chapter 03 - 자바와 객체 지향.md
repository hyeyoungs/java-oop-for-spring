# 03 자바와 객체 지향
> 객체 지향을 이해해보자. 객체 지향이 직관적이고 쉽고 인간적이다는 증거를 하나하나 살펴보자.
## 객체 지향의 등장
- 구조적 프로그래밍 (함수, 논리적으로 분할) ⎯ 우리가 주변에서 사물을 인지하는 방식대로 프로그래밍 할 수 있을까? → 객체 지향
- 속성과 메서드를 객체라는 단위로 묶는다.
- 객체 지향은 직관적이고 쉽고 인간적이다.

<br>

## 객체지향 4대 특성 - 캡! 상추다
- 캡슐화(Encapsulation) : 정보은닉(Information Hiding)
- 상속(extend) : 재사용 + 확장
- 추상화(Abstraction) : 모델링
- 다형성(Polymorphism) : 사용편의

<br>

## 클래스 vs 객체 == 붕어빵틀 vs 붕어빵 ???
클래스와 객체의 관계 == 분류(class)와 사물(object)의 관계        
클래스 : 객체 = 펭귄 : 뽀로로

<br>

## 추상화 : 모델링 
- 추상화란 구체적인 것을 분해해서 관심 영역에 대해서만 특성을 가지고 재조합 하는 것이다.       
- 이를 IT 용어로 풀어쓰면 다음과 같다.<br>
  추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션의 경계, Application Boundary)에 있는 특성만 가지고 재조합 하는 것 = 모델링
<br><br>
- 병원 애플리케이션을 만들 때 사람은 환자의 관점으로 바라볼 것이다.<br>
  클래스 모델링을 할 때 시력, 키, 몸무게, 혈액형, 나이 등, 먹다(), 자다(), 운동하다() 등으로 할 수 있다.
- 은행 애플리케이션을 만들 때 사람은 고객 관점으로 바라볼 것이다. <br> 
  클래스 모델링을 할 때 키, 혈액형은 필요가 없으며, 나이, 직접, 연봉, 신용등급, 입금하다(), 출금하다(), 대출하다() 등으로 할 수 있다.
<br><br>
- 모델링은 실제 사물을 정확하게 복제하는 것이 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 
  <br>즉, 모델은 추상화를 통해서 실제 사물을 단순하게 묘사하는 것입니다.
<br><br>

- 클래스와 객체 관계를 자바에서는 다음과 같이 표현한다.
- 새로운 객체를 하나 생성해 그 객체의 주소값을 객체 참조 변수에 할당

|클래스|객체_참조_변수|=|new|클래스|()|
|------|---|---|---|---|---|
|객체_참조_변수의 자료형(Type)|생성된 객체를 참조할 수 있는 변수|할당문|새로운|만들고자 하는 객체의 분류|메서드|
|  |  |  | 클래스의 인스턴스, 즉 객체를 생성하기 위해 객체 생성자를 호출    |

<br>

### 추상화와 Runtime Data 영역의 메모리
- java.lang 패키지와 모든 클래스들이 JVM의 Runtime Data 영역 중 Static 영역(= Method 영역)에 배치된다.
- Static 영역의 Class에는 객체에 속한 속성에 대한 저장 공간이 안 보이고 그저 이름만 존재한다.
  - 객체에 속한 속성은 객체가 생성돼야만 속성의 값을 저장하기 위한 메모리 공간이 Heap 영역에 할당된다. 

``` Java
Mouse mickey = new Mouse()

Mouse mickey // Mouse 객체에 대한 참조변수 mickey를 만든다.
new Mouse() // Mosue 클래스의 인스턴스를 하나 만들어 힙에 배치한다.
대입문 // Mouse 객체에 대한 주소(포인터)를 참조 변수 mickey에 할당한다.

→ 객체 참조 변수 Mickey는 Mouse 클래스의 인스턴스를 참조한다.  
```

<br>

### 클래스 멤버 vs 객체 멤버 = static 멤버 vs 인스턴스 멤버
같은 클래스(유형)의 모든 객체가 같은 값을 가지고 있다면 그 값은 클래스에 저장해보자.       
→ static 키워드를 속성 앞에 붙이면 된다. → 해당 속성은 스태틱 영역에 단 하나의 저장 공간을 갖게 된다.        

- static 속성 : Runtime Data 영역의 스태틱(=Method) 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보된다.
- 객체 속성 : 속성 명만 클래스 내부에 있고. 힙 영역에 객체가 생성되면 그때 각 객체 안에 멤버 속성을 위한 메모리 공간이 할당 된다.

공유 변수는 지역 변수와 다르게 초기화한다. 이는 초기화의 주체가 명확하지 않기 때문이다.

<br>

## 상속 : 재사용 + 확장
상속이라는 단어 때문에 많은 오해를 낳는다. 객체지향의 상속에 대한 잘못된 예는 - 계층도 / 조직도이다.         
객체 지향의 상속은 `재사용과 확장`의 의미로 이해하는 것이 맞다. 즉 `분류도`로 이해해야 합니다.        
객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다.     
상속 관계에는 '하위 클래스는 상위 클래스이다.' 문장이 반드시 만족해야 한다. (이는 LSP-라스코프 치환 원칙과 통한다.)     
하위 클래스 `is a kind of` 상위 클래스

<br>

### 다중 상속과 자바
- 다중 상속의 문제점 
  - 사람은 수영할 수 있고 물고기도 수영할 수 있다. 
  - 그렇다면 사람의 속성, 물고기의 속성을 가지고 있는 인어는 어떻게 수영해야 할까? <br>물고기처럼 꼬리를 사용해서 헤엄쳐야 할까? 사람처럼 팔과 다리를 저어서 헤엄쳐야 할까? 
  - 다중 상속을 하게되면 이러한 모호성이 생긴다. 이것을 다이아몬드 문제 라고 한다.

<br>

### 상속과 인터페이스
- 자바에서는 C++에는 없는 인터페이스를 도입해서 상속이 갖는 장점만 갖게 된다.


- 상속 관계 : 하위 클래스 is a kind of 상위 클래스
- 인터페이스 : 구현 클래스 is able to 인터페이스


- 인터페이스는 클래스가 '무엇을 할 수 있다' 라고 하는 기능을 구현하도록 강제한다.


- 상위 클래스는 물러줄 특성이 풍성할수록 좋고( LSP ), 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다( ISP )는 결론에 도달할 수 있다.

<br>

### 상속과 Runtime Data 영역의 메모리
- 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.

<br>

## 다형성 : 사용 편의성
객체 지향에서 다형성은 오버라이딩(Overriding)과 오버로딩(Overloading)이라고 할 수 있다.
- 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의


- 오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 되니 사용하기가 편리하다.
- 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다.


- 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복정의를 통해 다형성을 제공하고, 이 다형성이 개발자가 프로그램을 작성할 때 편리성을 준다.

<br>

## 캡슐화 : 정보은닉
접근 제어자를 통한 캡슐화를 진행한다.      
접근 제어자를 통해 외부의 잘못된 사용으로 객체가 손상되지 않도록 한다. 이를 통해 변화에 유연하게 대응한다.

<br>

### 객체 멤버의 접근 제어자
- 자신의 멤버가 아닌 다른 객체의 멤버에 접근하는 경우에는 다른 객체를 생성한 후 접근해야 한다.
- 접근 제어자가 객체 멤버와 static 멤버와 함께 쓰일 때를 비교해보자.
  - 상속 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
  - static 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

<br>

# 읽은 후 알게된 개념과 소감
- 객체 지향의 특징인 캡슐화, 상속, 다형성, 추상화에 대해 알 수 있었다.
- 캡슐화 : 접근 제어자를 통해, 클래스를 외부에서 맘대로 접근하지 못하게 하는 것
- 상속 : 위 클래스의 특성을 하위 클래스에서 상속하고 필요한 특성을 추가하여, 확장해서 사용
- 다형성 : overriding, overloading
- 추상화 : 객체의 공통된 속성이나 기능 중 목적에 맞는 관심 대상만을 집중하여 추출하는 것
